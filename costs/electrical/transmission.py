"""
Transmission Cost Functions (Physics-Based HVAC/HVDC)
=====================================================

Offshore-to-shore transmission costs using physics-based models.

Methodology: see writing/electrical-infrastructure/transmission.md
"""

import numpy as np
import pandas as pd

from tidal_portfolio.config import AC_CABLE_DATA_PATH, DC_CABLE_DATA_PATH


# =============================================================================
# CONFIGURATION
# =============================================================================

TECHNICAL = {
    'LINE_LENGTH_FACTOR': 1.2,      # Account for cable routing (not straight line)
    'TRANSFORMER_EFF': 0.997,       # HVAC transformer efficiency
    'CONVERTER_EFF': 0.982,         # HVDC converter efficiency
    'GRID_FREQUENCY': 60,           # Hz (US grid)
}


# =============================================================================
# CABLE DATA LOADING
# =============================================================================

def load_ac_cable_data(path=None):
    """
    Load AC cable parameters from Excel.

    Args:
        path: Path to Excel file (default: from config.AC_CABLE_DATA_PATH)

    Returns:
        DataFrame with columns:
            - Voltage [KV]
            - Cross Section [mm]
            - Current Capacity [A]
            - MVA Capacity
            - Resistance [Ohm/Km]
            - Capacitance [MicroF/Km]
            - Inductance [mF/Km]
            - Cable Cost [$/m]
            - Observations (Copper/Aluminium)
    """
    if path is None:
        path = AC_CABLE_DATA_PATH
    return pd.read_excel(path)


def load_dc_cable_data(path=None):
    """
    Load DC cable parameters from Excel.

    Args:
        path: Path to Excel file (default: from config.DC_CABLE_DATA_PATH)

    Returns:
        DataFrame with columns:
            - Voltage [KV]
            - Cross Section [mm]
            - Current Capacity [A]
            - MVA Capacity
            - Resistance [Ohm/Km]
            - Cable Cost [$/m]
    """
    if path is None:
        path = DC_CABLE_DATA_PATH
    return pd.read_excel(path)


# =============================================================================
# HVAC FUNCTIONS
# =============================================================================

def calculate_ac_power_parameters(voltage_kv, resistance, capacitance, inductance,
                                   mva_capacity, shore_distance_km, rated_power_mw,
                                   add_extra_cable=0):
    """
    Calculate power parameters for an AC transmission line.

    Uses transmission line theory to account for:
    - Propagation constant (γ) from R, L, C parameters
    - Shunt admittance and reactive power generation
    - Active power capacity reduction due to reactive power

    Args:
        voltage_kv: Cable voltage in kV
        resistance: Cable resistance in Ohm/km
        capacitance: Cable capacitance in µF/km
        inductance: Cable inductance in mH/km
        mva_capacity: Cable MVA rating (single conductor)
        shore_distance_km: Distance from shore to collection point
        rated_power_mw: Rated generation power
        add_extra_cable: Number of extra cables for redundancy

    Returns:
        dict with:
            - P_max: Maximum active power capacity [MW]
            - S_max: Total apparent power capacity [MVA]
            - Q_total: Total reactive power [MVAr]
            - num_conductors: Number of parallel cables needed
            - feasible: Whether this cable configuration works
    """
    # Calculate line length with routing factor
    line_length = shore_distance_km * TECHNICAL['LINE_LENGTH_FACTOR']

    # Angular frequency
    omega = 2 * np.pi * TECHNICAL['GRID_FREQUENCY']

    # Calculate propagation constant γ = sqrt((R + jωL)(jωC))
    # where L is in H/km and C is in F/km
    Z = resistance + 1j * omega * inductance * 1e-3  # Series impedance per km
    Y = 1j * omega * capacitance * 1e-6              # Shunt admittance per km
    gamma = np.sqrt(Z * Y)                            # Propagation constant

    # Calculate total shunt admittance using hyperbolic correction
    # Y_total = jωCL × tanh(γL/2) / (γL/2)
    gamma_L_half = gamma * line_length / 2
    if np.abs(gamma_L_half) < 1e-10:
        # Avoid division by zero for very short lines
        Y_total = 1j * omega * capacitance * 1e-6 * line_length
    else:
        Y_total = (1j * omega * capacitance * 1e-6 * line_length *
                   np.tanh(gamma_L_half) / gamma_L_half)

    # Reactive power generated by one cable [MVAr]
    Q_single = Y_total.imag * voltage_kv**2

    # Calculate maximum active power capacity after reactive power deduction
    # P_max = sqrt(S^2 - (Q/2)^2) where Q/2 is the reactive power at each end
    Q_half_squared = (Q_single / 2) ** 2
    S_squared = mva_capacity ** 2

    if S_squared <= Q_half_squared:
        # Cable cannot transmit any active power at this distance
        return {
            'P_max': 0,
            'S_max': 0,
            'Q_total': Q_single,
            'num_conductors': 0,
            'feasible': False,
            'line_length_km': line_length,
        }

    # Maximum active power per conductor [MW]
    P_per_conductor = np.sqrt(S_squared - Q_half_squared)

    # Determine number of conductors needed
    if rated_power_mw > P_per_conductor:
        num_conductors = int(np.ceil(rated_power_mw / P_per_conductor))
    else:
        num_conductors = 1

    num_conductors += add_extra_cable

    # Total capacities
    P_max = P_per_conductor * num_conductors
    S_max = mva_capacity * num_conductors
    Q_total = Q_single * num_conductors

    return {
        'P_max': P_max,
        'S_max': S_max,
        'Q_total': Q_total,
        'num_conductors': num_conductors,
        'feasible': True,
        'line_length_km': line_length,
        'P_per_conductor': P_per_conductor,
        'Q_per_conductor': Q_single,
    }


def calculate_ac_efficiency(voltage_kv, resistance, num_conductors,
                            shore_distance_km, rated_power_mw, capacity_factor):
    """
    Calculate the efficiency of an AC transmission line.

    Losses include:
    - Offshore transformer losses: (1 - η_T) × P
    - Cable I²R losses: n × R × L × (P / (V × n))²
    - Onshore transformer losses: (P - cable_losses) × (1 - η_T)

    Args:
        voltage_kv: Cable voltage in kV
        resistance: Cable resistance in Ohm/km
        num_conductors: Number of parallel cables
        shore_distance_km: Distance from shore to collection point
        rated_power_mw: Rated generation power
        capacity_factor: Site-specific capacity factor

    Returns:
        tuple: (efficiency, total_losses_mw)
    """
    transformer_eff = TECHNICAL['TRANSFORMER_EFF']
    line_length = shore_distance_km * TECHNICAL['LINE_LENGTH_FACTOR']

    # Actual power being transmitted (average)
    actual_power_mw = rated_power_mw * capacity_factor

    # Offshore transformer losses
    offshore_losses = (1 - transformer_eff) * actual_power_mw

    # Power after offshore transformer
    power_after_offshore = actual_power_mw * transformer_eff

    # Cable I²R losses
    # P_loss = I²R × L × n, where I = P / (V × n × √3) for 3-phase
    # Simplified: P_loss = n × R × L × (P / (V × n))² / 1000 for MW
    current_per_cable = power_after_offshore / (voltage_kv * num_conductors)  # Simplified
    cable_losses = num_conductors * resistance * line_length * (current_per_cable ** 2) / 1000

    # Power after cable
    power_after_cable = power_after_offshore - cable_losses

    # Onshore transformer losses
    onshore_losses = (1 - transformer_eff) * power_after_cable

    # Total losses
    total_losses = offshore_losses + cable_losses + onshore_losses

    # Efficiency
    if actual_power_mw > 0:
        efficiency = 1 - total_losses / actual_power_mw
    else:
        efficiency = 0

    return efficiency, total_losses


def calculate_hvac_cost(shore_distance_km, rated_power_mw, capacity_factor,
                        fcr, opex_rate, cable_data=None,
                        min_voltage_kv=None, max_voltage_kv=None,
                        material=None, add_extra_cable=0):
    """
    Calculate HVAC transmission costs.

    Evaluates all feasible cables and returns the cheapest option.

    Args:
        shore_distance_km: Distance from collection point to shore
        rated_power_mw: Total project capacity in MW
        capacity_factor: Average capacity factor (for efficiency calculation)
        fcr: Fixed charge rate
        opex_rate: OPEX as fraction of CAPEX
        cable_data: DataFrame of AC cables (loads default if None)
        min_voltage_kv: Filter - minimum voltage to consider
        max_voltage_kv: Filter - maximum voltage to consider
        material: Filter - 'Copper', 'Aluminium', or None (both)
        add_extra_cable: Number of extra cables for redundancy

    Returns:
        dict with best cable selection, costs breakdown, efficiency
        Returns None if no feasible cable found
    """
    if cable_data is None:
        cable_data = load_ac_cable_data()

    line_length = shore_distance_km * TECHNICAL['LINE_LENGTH_FACTOR']

    best_result = None
    best_annualized = float('inf')
    evaluated_cables = []

    for idx, row in cable_data.iterrows():
        voltage_kv = row['Voltage [KV]']
        resistance = row['Resistance [Ohm/Km]']
        capacitance = row['Capacitance [MicroF/Km]']
        inductance = row['Inductance [mF/Km]']
        mva_capacity = row['MVA Capacity']
        cable_cost_per_m = row['Cable Cost [$/m]']
        cable_material = row.get('Observations', 'Unknown')

        # Apply filters
        if min_voltage_kv is not None and voltage_kv < min_voltage_kv:
            continue
        if max_voltage_kv is not None and voltage_kv > max_voltage_kv:
            continue
        if material is not None and cable_material != material:
            continue

        # Calculate power parameters (feasibility check)
        power_params = calculate_ac_power_parameters(
            voltage_kv=voltage_kv,
            resistance=resistance,
            capacitance=capacitance,
            inductance=inductance,
            mva_capacity=mva_capacity,
            shore_distance_km=shore_distance_km,
            rated_power_mw=rated_power_mw,
            add_extra_cable=add_extra_cable,
        )

        if not power_params['feasible']:
            evaluated_cables.append({
                'voltage_kv': voltage_kv,
                'cross_section': row['Cross Section [mm]'],
                'material': cable_material,
                'feasible': False,
                'reason': 'Reactive power exceeds capacity',
            })
            continue

        num_conductors = power_params['num_conductors']
        S_total = power_params['S_max']
        Q_total = power_params['Q_total']

        # Calculate efficiency
        efficiency, losses = calculate_ac_efficiency(
            voltage_kv=voltage_kv,
            resistance=resistance,
            num_conductors=num_conductors,
            shore_distance_km=shore_distance_km,
            rated_power_mw=rated_power_mw,
            capacity_factor=capacity_factor,
        )

        # Calculate CAPEX components [M$]
        cable_cost_per_km = cable_cost_per_m * 1e-3  # Convert $/m to M$/km

        # Offshore platform and plant cost [M$]
        oppc_ac = 6.55 + 0.0472 * S_total

        # Onshore plant cost [M$]
        opc_ac = 0.03434 * (S_total ** 0.7513)

        # Reactive power compensation cost [M$]
        qc_ac = 0.0262 * Q_total

        # Cable cost + cable landing + cable installation [M$]
        cc_ac = (cable_cost_per_km * num_conductors * line_length +
                 0.221 * shore_distance_km +
                 4.245e-3 * S_total +
                 0.629)

        # Total CAPEX [M$]
        capex_m = oppc_ac + opc_ac + qc_ac + cc_ac

        # OPEX [M$/year]
        opex_m = opex_rate * capex_m

        # Annualized cost [M$/year]
        annualized_m = fcr * capex_m + opex_m

        evaluated_cables.append({
            'voltage_kv': voltage_kv,
            'cross_section': row['Cross Section [mm]'],
            'material': cable_material,
            'feasible': True,
            'num_conductors': num_conductors,
            'annualized_cost_m': annualized_m,
        })

        # Check if this is the best option
        if annualized_m < best_annualized:
            best_annualized = annualized_m
            best_result = {
                'mode': 'HVAC',
                'feasible': True,
                # Cable info
                'cable': {
                    'voltage_kv': voltage_kv,
                    'cross_section_mm': row['Cross Section [mm]'],
                    'material': cable_material,
                    'resistance_ohm_km': resistance,
                    'mva_capacity_per_cable': mva_capacity,
                    'cost_per_km': cable_cost_per_m * 1e3,  # $/km
                },
                # Power parameters
                'num_conductors': num_conductors,
                'P_max_mw': power_params['P_max'],
                'S_total_mva': S_total,
                'Q_total_mvar': Q_total,
                'line_length_km': line_length,
                # Costs [$ not M$]
                'capex': {
                    'offshore_platform': oppc_ac * 1e6,
                    'onshore_plant': opc_ac * 1e6,
                    'reactive_compensation': qc_ac * 1e6,
                    'cable_and_installation': cc_ac * 1e6,
                    'total': capex_m * 1e6,
                },
                'opex': opex_m * 1e6,
                'annualized_cost': annualized_m * 1e6,
                # Efficiency
                'efficiency': efficiency,
                'losses_mw': losses,
                # Parameters used
                'fcr': fcr,
                'opex_rate': opex_rate,
                'shore_distance_km': shore_distance_km,
                'rated_power_mw': rated_power_mw,
                'capacity_factor': capacity_factor,
            }

    if best_result is not None:
        best_result['cables_evaluated'] = len(evaluated_cables)
        best_result['cables_feasible'] = sum(1 for c in evaluated_cables if c['feasible'])

    return best_result


# =============================================================================
# HVDC FUNCTIONS
# =============================================================================

def calculate_dc_efficiency(voltage_kv, resistance, num_conductors,
                            shore_distance_km, rated_power_mw, capacity_factor):
    """
    Calculate the efficiency of a DC transmission line.

    Losses include:
    - Offshore converter losses: (1 - η_C) × P
    - Cable I²R losses: 2 × R × L × (P / (2 × V × n))²
    - Onshore converter losses: (P - cable_losses) × (1 - η_C)

    Args:
        voltage_kv: Cable voltage in kV
        resistance: Cable resistance in Ohm/km
        num_conductors: Number of parallel cable pairs
        shore_distance_km: Distance from shore to collection point
        rated_power_mw: Rated generation power
        capacity_factor: Site-specific capacity factor

    Returns:
        tuple: (efficiency, total_losses_mw)
    """
    converter_eff = TECHNICAL['CONVERTER_EFF']
    line_length = shore_distance_km * TECHNICAL['LINE_LENGTH_FACTOR']

    # Actual power being transmitted (average)
    actual_power_mw = rated_power_mw * capacity_factor

    # Offshore converter losses
    offshore_losses = (1 - converter_eff) * actual_power_mw

    # Power after offshore converter
    power_after_offshore = actual_power_mw * converter_eff

    # Cable I²R losses (bipolar DC: current splits between + and - poles)
    # I = P / (2 × V × n) for bipolar
    current_per_pole = power_after_offshore / (2 * voltage_kv * num_conductors)
    # Loss in both poles: 2 × R × L × I²
    cable_losses = 2 * resistance * line_length * (current_per_pole ** 2) / 1000

    # Power after cable
    power_after_cable = power_after_offshore - cable_losses

    # Onshore converter losses
    onshore_losses = (1 - converter_eff) * power_after_cable

    # Total losses
    total_losses = offshore_losses + cable_losses + onshore_losses

    # Efficiency
    if actual_power_mw > 0:
        efficiency = 1 - total_losses / actual_power_mw
    else:
        efficiency = 0

    return efficiency, total_losses


def calculate_hvdc_cost(shore_distance_km, rated_power_mw, capacity_factor,
                        fcr, opex_rate, cable_data=None,
                        min_voltage_kv=None, max_voltage_kv=None,
                        add_extra_cable=0):
    """
    Calculate HVDC transmission costs.

    Evaluates all feasible cables and returns the cheapest option.

    Args:
        shore_distance_km: Distance from collection point to shore
        rated_power_mw: Total project capacity in MW
        capacity_factor: Average capacity factor (for efficiency calculation)
        fcr: Fixed charge rate
        opex_rate: OPEX as fraction of CAPEX
        cable_data: DataFrame of DC cables (loads default if None)
        min_voltage_kv: Filter - minimum voltage to consider
        max_voltage_kv: Filter - maximum voltage to consider
        add_extra_cable: Number of extra cables for redundancy

    Returns:
        dict with best cable selection, costs breakdown, efficiency
        Returns None if no feasible cable found
    """
    if cable_data is None:
        cable_data = load_dc_cable_data()

    line_length = shore_distance_km * TECHNICAL['LINE_LENGTH_FACTOR']

    best_result = None
    best_annualized = float('inf')
    evaluated_cables = []

    for idx, row in cable_data.iterrows():
        voltage_kv = row['Voltage [KV]']
        resistance = row['Resistance [Ohm/Km]']
        mva_capacity = row['MVA Capacity']
        cable_cost_per_m = row['Cable Cost [$/m]']

        # Apply filters
        if min_voltage_kv is not None and voltage_kv < min_voltage_kv:
            continue
        if max_voltage_kv is not None and voltage_kv > max_voltage_kv:
            continue

        # DC cables are always feasible - just need more parallel cables
        num_conductors = int(np.ceil(rated_power_mw / mva_capacity)) + add_extra_cable

        # Calculate efficiency
        efficiency, losses = calculate_dc_efficiency(
            voltage_kv=voltage_kv,
            resistance=resistance,
            num_conductors=num_conductors,
            shore_distance_km=shore_distance_km,
            rated_power_mw=rated_power_mw,
            capacity_factor=capacity_factor,
        )

        # Calculate CAPEX components [M$]
        cable_cost_per_km = cable_cost_per_m * 1e-3  # Convert $/m to M$/km

        # Offshore platform and plant cost [M$]
        oppc_dc = 32.75 + 0.07205 * rated_power_mw

        # Onshore plant cost [M$]
        opc_dc = 0.1067 * rated_power_mw

        # Cable cost + cable landing + cable installation [M$]
        cc_dc = (cable_cost_per_km * num_conductors * line_length +
                 0.221 * shore_distance_km +
                 4.245e-3 * rated_power_mw +
                 0.629)

        # Total CAPEX [M$]
        capex_m = oppc_dc + opc_dc + cc_dc

        # OPEX [M$/year]
        opex_m = opex_rate * capex_m

        # Annualized cost [M$/year]
        annualized_m = fcr * capex_m + opex_m

        evaluated_cables.append({
            'voltage_kv': voltage_kv,
            'cross_section': row['Cross Section [mm]'],
            'feasible': True,
            'num_conductors': num_conductors,
            'annualized_cost_m': annualized_m,
        })

        # Check if this is the best option
        if annualized_m < best_annualized:
            best_annualized = annualized_m
            best_result = {
                'mode': 'HVDC',
                'feasible': True,
                # Cable info
                'cable': {
                    'voltage_kv': voltage_kv,
                    'cross_section_mm': row['Cross Section [mm]'],
                    'resistance_ohm_km': resistance,
                    'mva_capacity_per_cable': mva_capacity,
                    'cost_per_km': cable_cost_per_m * 1e3,  # $/km
                },
                # Power parameters
                'num_conductors': num_conductors,
                'P_max_mw': mva_capacity * num_conductors,
                'line_length_km': line_length,
                # Costs [$ not M$]
                'capex': {
                    'offshore_platform': oppc_dc * 1e6,
                    'onshore_plant': opc_dc * 1e6,
                    'cable_and_installation': cc_dc * 1e6,
                    'total': capex_m * 1e6,
                },
                'opex': opex_m * 1e6,
                'annualized_cost': annualized_m * 1e6,
                # Efficiency
                'efficiency': efficiency,
                'losses_mw': losses,
                # Parameters used
                'fcr': fcr,
                'opex_rate': opex_rate,
                'shore_distance_km': shore_distance_km,
                'rated_power_mw': rated_power_mw,
                'capacity_factor': capacity_factor,
            }

    if best_result is not None:
        best_result['cables_evaluated'] = len(evaluated_cables)

    return best_result


# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def calculate_transmission_cost(shore_distance_km, project_capacity_mw,
                                 capacity_factor, fcr, opex_rate,
                                 force_mode=None, ac_cable_data=None, dc_cable_data=None,
                                 min_voltage_kv=None, max_voltage_kv=None,
                                 material=None, add_extra_cable=0):
    """
    Calculate optimal transmission costs (auto-selects HVAC or HVDC).

    Evaluates both AC and DC options with all feasible cables,
    then returns the cheaper configuration (unless force_mode is specified).

    Args:
        shore_distance_km: Distance from collection point to shore
        project_capacity_mw: Total project capacity in MW
        capacity_factor: Average capacity factor
        fcr: Fixed charge rate
        opex_rate: OPEX as fraction of CAPEX
        force_mode: Force 'HVAC' or 'HVDC' (optional)
        ac_cable_data: DataFrame of AC cables (loads default if None)
        dc_cable_data: DataFrame of DC cables (loads default if None)
        min_voltage_kv: Filter - minimum voltage to consider
        max_voltage_kv: Filter - maximum voltage to consider
        material: Filter for AC cables - 'Copper', 'Aluminium', or None
        add_extra_cable: Number of extra cables for redundancy

    Returns:
        dict with:
            - mode: 'HVAC' or 'HVDC'
            - cable: Selected cable specifications
            - num_conductors: Number of parallel cables
            - capex: Cost breakdown (offshore_platform, onshore_plant, etc.)
            - opex: Annual operating cost
            - annualized_cost: FCR x CAPEX + OPEX
            - efficiency: Transmission efficiency
            - comparison: Both AC and DC results for reference
    """
    # Calculate HVAC option
    hvac_result = None
    if force_mode != 'HVDC':
        hvac_result = calculate_hvac_cost(
            shore_distance_km=shore_distance_km,
            rated_power_mw=project_capacity_mw,
            capacity_factor=capacity_factor,
            fcr=fcr,
            opex_rate=opex_rate,
            cable_data=ac_cable_data,
            min_voltage_kv=min_voltage_kv,
            max_voltage_kv=max_voltage_kv,
            material=material,
            add_extra_cable=add_extra_cable,
        )

    # Calculate HVDC option
    hvdc_result = None
    if force_mode != 'HVAC':
        hvdc_result = calculate_hvdc_cost(
            shore_distance_km=shore_distance_km,
            rated_power_mw=project_capacity_mw,
            capacity_factor=capacity_factor,
            fcr=fcr,
            opex_rate=opex_rate,
            cable_data=dc_cable_data,
            min_voltage_kv=min_voltage_kv,
            max_voltage_kv=max_voltage_kv,
            add_extra_cable=add_extra_cable,
        )

    # Select the best option
    if force_mode == 'HVAC':
        best = hvac_result
    elif force_mode == 'HVDC':
        best = hvdc_result
    elif hvac_result is None and hvdc_result is None:
        # No feasible option
        return {
            'mode': None,
            'feasible': False,
            'reason': 'No feasible AC or DC cable found for this configuration',
            'shore_distance_km': shore_distance_km,
            'project_capacity_mw': project_capacity_mw,
        }
    elif hvac_result is None:
        best = hvdc_result
    elif hvdc_result is None:
        best = hvac_result
    else:
        # Both feasible - pick cheaper
        if hvac_result['annualized_cost'] <= hvdc_result['annualized_cost']:
            best = hvac_result
        else:
            best = hvdc_result

    # Add comparison info
    if best is not None:
        best['comparison'] = {
            'hvac': {
                'feasible': hvac_result is not None,
                'annualized_cost': hvac_result['annualized_cost'] if hvac_result else None,
                'voltage_kv': hvac_result['cable']['voltage_kv'] if hvac_result else None,
                'num_conductors': hvac_result['num_conductors'] if hvac_result else None,
            },
            'hvdc': {
                'feasible': hvdc_result is not None,
                'annualized_cost': hvdc_result['annualized_cost'] if hvdc_result else None,
                'voltage_kv': hvdc_result['cable']['voltage_kv'] if hvdc_result else None,
                'num_conductors': hvdc_result['num_conductors'] if hvdc_result else None,
            },
        }

    return best
